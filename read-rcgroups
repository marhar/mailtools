#!/usr/bin/env python
"""
#-----------------------------------------------------------------------
read-rcgroups -- read new messages on rcgroups.com

rcgroups sends a set of nightly emails (one per subscribed thread)
telling you what's new to be read.  this program grabs those messages,
opens the threads in your browser, and deletes the messages.  Don't
be alarmed if it opens a lot of tabs.

If you use gmail, add this filter:
    Matches: from:(rcgroups.com@vsobr.com)
    Do this: Skip Inbox, Apply label "[Gmail]/rcgroups"

usage: read-rcgroups [mailserver]

This is part of the mailtools package : (c) 2015 Mark Harrison
https://github.com/marhar/mailtools   :     Share and Enjoy!
"""

#-----------------------------------------------------------------------
import sys,re,time,os,email
import mailcfg

#-----------------------------------------------------------------------
def doopen(url):
    """open this url in a browser
       currently works for mac.  if you're on another system let me
       know what works!
    """
    os.system("open '%s'"%(url))
    #time.sleep(.25)  # this delay seems to makes opening smoother

#-----------------------------------------------------------------------
# handy re's for rcgroups email
#-----------------------------------------------------------------------
re_http=re.compile(r'^(http://.*)$')
re_http=re.compile(r'^(https://www.rcgroups.com/.*)$')
re_subj=re.compile(r'Subject: (.*)')
re_thread=re.compile(r'^(You are subscribed to the thread.*)')
re_forum=re.compile(r'^You are subscribed to the forum[^,]*, (.*)')

#-----------------------------------------------------------------------
def contains(re,s):
    """does s contain this re?"""
    mm=re.search(x)
    if mm:
        res=mm.group(1)
    else:
        res=None
    return res

#-----------------------------------------------------------------------
def url(s):
    """look for the strings that indicate unread forums or threads.

       this is a bunch of hacky stuff that looks in the email body
       and tries to figure out what's not read.  Hope rcgroups never
       changes the body format!  Even better that they include a
       nice json summary.
    """

    http=None
    for x in s.split('\n'):
        x=x.replace('\r','')
        mm=re_http.search(x)
        if mm:
            http=mm.group(1)
            http=http.replace(' ','')
            http+='&goto=newpost'
            break   # must break, or you will pick up the unsubscribe link

    return http

#-----------------------------------------------------------------------
def main():
    """Our main business is not to see what lies dimly at a
       distance, but to do what lies clearly at hand.
          --Thomas Carlyle
    """

    showstart()
    logger = open("rcreader.log", "a")
    logger.write("-----------\n")
    logger.flush()
    if len(sys.argv) > 1:      # max messages to process (including dupes)
        N=int(sys.argv[1])
    else:
        N=200

    if len(sys.argv) > 2:      # default to gmail
        server=sys.argv[2]
    else:
        server='gmail'

    m=mailcfg.imapserver(server)
    rc,data=m.select('[Gmail]/rcgroups') # we filter to here on gmail
    mailcfg.ok(rc,data)

    rc,data=m.search(None, '(FROM "rcgroups.com@vsobr.com")')
    mailcfg.ok(rc,data)

    seen={}
    nshown=0
    nskipped = 0
    totmsgs=len(data[0].split())
    #print 'messages:',totmsgs
    statstr = ""
    i = 0
    for msgno in data[0].split():
        i += 1
        rc,data=m.fetch(msgno,'(RFC822)')
        mailcfg.ok(rc,data)
        body=email.message_from_string(data[0][1])
        h=url(str(body))
        if seen.has_key(h) == False:
            nshown += 1
            seen[h] = 1
            #print h
            logger.write("open '" +h + "'\n")
            logger.flush()
            statstr += "."
            if DOIT: doopen(h)
            show(i, totmsgs, nskipped, ".", runstate)
        else:
            show(i, totmsgs, nskipped, "o", runstate)
            nskipped += 1
            #print '# (skip)', h
            statstr += "o"
        if DOIT: m.store(msgno, '+FLAGS', '\Deleted')

        if nshown >= N:
            print '*** stopped after first %d, %d left'%(N,totmsgs-N)
            break

    sys.stdout.write("\n%d opened %d skipped\n" % (nshown, nskipped))
    m.close()
    m.logout()

def ttt(s):
    """write string to screen"""
    sys.stdout.write(s)
    sys.stdout.flush()

def showstart():
    ttt("\033[2J\033[H")

def show(i, totmsgs, nskipped, ch, extra):
    WIDTH = 10
    ttt("\033[H%d %d %d %s"%(totmsgs, i, nskipped, extra))
    cc = (i - 1) // WIDTH
    rr = (i - 1) % WIDTH
    rr += 1
    cc += 2
    ttt("\033[%d;%dH%s"%(cc,rr,ch))
    time.sleep(DELAY)

#-----------------------------------------------------------------------
DELAY=0  # make larger for debugging or for slow computer
DOIT=True
#DOIT=False  # uncomment for testing
if (not DOIT):
    runstate = "DRY RUN MODE"
else:
    runstate = ""

try:
    main()
except KeyboardInterrupt:
    pass
